{"name":"Message","tagline":"","body":"### Stream reader and writer\r\n\r\nLibrarys main purpose are six functions: \r\n\r\n```\r\nint  cb_set_cursor(CBFILE **cbs, char **name, int *namelength);\r\n\r\nint  cb_remove_name_from_stream(CBFILE **cbs);\r\n```\r\n\r\ncb_set_cursor finds a name from streams name-value pairs and sets the cursor to the end of the name. While the function is reading the stream it places it's data in a buffer and saves every name it finds in it's memory structure. It finds every name from buffer according to it's data structures information of offsets of the names when reading again. \r\n\r\nThe buffer does not move with the stream. When the end of buffer is reached, name-value pairs must be in the order they are used. It is best if name-value pairs are in the same order in the input as is the order of using them. If buffer end is reached, CBSTREAM is returned. If this happens, the last names value may be at the border of buffer. In these cases the name must be removed from data structure with cb_remove_name_from_stream. \r\n\r\n```\r\nint  cb_get_chr(CBFILE **cbs, unsigned long int *chr, int *bytecount, int *storedbytes);\r\nint  cb_put_chr(CBFILE **cbs, unsigned long int *chr, int *bytecount, int *storedbytes);\r\n```\r\n\r\nLibrary reads UCS 32-bit word length characters from UTF-8 transfer data. It reads and writes to or from one byte, two byte or UTF-8 encoded transfer data. \r\n\r\n#### Data structures\r\nPrimary data structures in CBFILE are: \r\n```\r\ntypedef struct CBFILE{\r\n        int    fd;      // Stream file descriptor\r\n        cbuf  *cb;      // Data in valuepairs (preferably in application order)\r\n        cblk  *blk;     // Input read or output write -block \r\n...\r\n} CBFILE;\r\n```\r\n     \r\n* file descriptor to read or write, fd\r\n* block to read or write, cblk\r\n* buffer to save read stream, cbuf\r\n\r\nPrimary data structures in structure to save the names are: \r\n```\r\ntypedef struct cb_name{\r\n...\r\n        char  *namebuf; // name\r\n        int   namelen; // name length\r\n        int   offset; // offset from the beginning of data\r\n        void  *next; // Last is NULL\r\n...\r\n} cb_name;\r\n```\r\nIt is a linked list. This is only to understand what happens in the library. Only above functions and CBFILE allocation functions are meant to be used:\r\n```\r\nint  cb_allocate_cbfile(CBFILE **buf, int fd, int bufsize, int blocksize);\r\nint  cb_free_cbfile(CBFILE **buf);\r\n```\r\nRemember to free CBFILE:s memory after using.\r\n\r\n####Data read\r\nData written and read are valuepairs. Value name may contain comments (between # and \\n). Flow control characters are:\r\n```\r\n'=' Separates data from it's name\r\n'&' Separates pairs\r\n'\\' Escapes next flow control character\r\n'#' Comment to next newline\r\n```\r\nCharacteres can be set to another. Tabs, new lines and white spaces are removed between pairs. \r\n\r\nExample:\r\n```\r\nname_of_value=data_of_value&another_name=another_data&   third_name=third_data&\r\n      fourth_name=fourth_data&\r\n```\r\n### Issue and bug tracking\r\nInformation about issues and bugs are welcomed. Very welcomed is information about using the library. Library is tested with some tests when writing this. It appears useful and bugs can be fixed.\r\n\r\n### Authors and Contributors\r\nJouni Laakso , contact: jnl (cat and tail) iki (dot) fi.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}