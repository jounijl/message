{"name":"Message","tagline":"","body":"### Stream reader and writer\r\n\r\nLibrarys main purpose are six functions: \r\n\r\n```\r\nint  cb_set_cursor(CBFILE **cbs, char **name, int *namelength);\r\n\r\nint  cb_remove_name_from_stream(CBFILE **cbs);\r\n```\r\n\r\ncb_set_cursor finds a name from streams name-value pairs and sets the cursor to the end of the name. While the function is reading the stream it places it's data in a buffer and saves every name it finds in it's memory structure. It finds every name from buffer according to it's data structures information of offsets of the names when reading again. \r\n\r\nThe buffer does not move with the stream. When the end of buffer is reached, name-value pairs must be in the order they are used. It is best if name-value pairs are in the same order in the input as is the order of using them. If buffer end is reached, CBSTREAM is returned. If this happens, the last names value may be at the border of buffer. In these cases the name must be removed from data structure with cb_remove_name_from_stream. \r\n\r\nIf you get CBSTREAM when reading a character, the block read has reached the buffer boundary and the character is not in the buffer anymore. You may have to do with it immediately what was needed to do because it's allready in stream and it's not automatically saved anymore. \r\n\r\n```\r\nint  cb_get_chr(CBFILE **cbs, unsigned long int *chr, int *bytecount, int *storedbytes);\r\nint  cb_put_chr(CBFILE **cbs, unsigned long int *chr, int *bytecount, int *storedbytes);\r\n```\r\n\r\nLibrary reads UCS 32-bit word length characters from UTF-8 transfer data. It reads and writes to or from one byte, two byte or UTF-8 encoded transfer data. Two byte functionality is not implemented when writing this.\r\n\r\nProgram sets bytecount and storedbytes. Bytecount is the count of bytes in stream and stored bytes is the size of the character after reading or before writing it.\r\n\r\n#### Data structures\r\nPrimary data structures in CBFILE are: \r\n```\r\ntypedef struct CBFILE{\r\n        int    fd;      // Stream file descriptor\r\n        cbuf  *cb;      // Data in valuepairs (preferably in application order)\r\n        cblk  *blk;     // Input read or output write -block \r\n...\r\n} CBFILE;\r\n```\r\n     \r\n* file descriptor to read or write, fd\r\n* block to read or write, cblk\r\n* buffer to save read stream, cbuf\r\n\r\nPrimary data structures in structure to save the names are: \r\n```\r\ntypedef struct cb_name{\r\n...\r\n        char  *namebuf; // name\r\n        int   namelen; // name length\r\n        int   offset; // offset from the beginning of data\r\n        void  *next; // Last is NULL\r\n...\r\n} cb_name;\r\n```\r\nIt is a linked list. This is only to understand what happens in the library. Only above functions and CBFILE allocation functions are meant to be used:\r\n```\r\nint  cb_allocate_cbfile(CBFILE **buf, int fd, int bufsize, int blocksize);\r\nint  cb_free_cbfile(CBFILE **buf);\r\n```\r\nRemember to free CBFILE:s memory after using.\r\n\r\n####Data read\r\nData written and read are valuepairs. Value name may contain comments (between # and \\n). Flow control characters are:\r\n```\r\n'=' Separates data from it's name\r\n'&' Separates pairs\r\n'\\' Escapes next flow control character\r\n'#' Comment to next newline\r\n```\r\nCharacters can be set to another. Tabs, new lines and white spaces are removed between pairs. Tabs and white spaces in names are removed before comparing them.\r\n\r\nFor example:\r\n```\r\nname_of_value=data_of_value&another_name=another_data&   third_name=third_data&\r\n      fourthname =fourth_data& # Comment\r\nname of last pair =last_p\\&air\\\\s_data& \r\n```\r\nLast pairs value has control characters. cb_get_chr function reads characters without flow control. It's in the programmers responsibility to implement bypass with '\\' and read beyond \"\\\\&\" after reading the characters if it's necessary. Remember to stop reading at '&'.\r\n\r\nExample of nesting consecutive streams:\r\n```\r\ndata_field {\r\n  name1 = value1;\r\n  name2 = value2; # Comment \r\n}\r\n```\r\nLibrary can be used for example in reading or writing configuration files, reading a POST responce from browser, parsing email header files or in interprocess messaging.\r\n\r\n### Issues and bug tracking\r\nInformation about issues and bugs are welcomed. Very welcomed is information about using the library. Library was tested with some tests before writing this. It appears useful and bugs can be fixed. Testing program (main.c) is still under construction.\r\n\r\n**Page history**\r\n[http://jounijl.github.com/message](http://jounijl.github.com/message)\r\n17:th of March 2013\r\n\r\n### Authors and Contributors\r\nJouni L. email: jnl (cat and tail) iki (dot) fi.\r\n","google":"UA-39364465-1","note":"Don't delete this file! It's used internally to help with page regeneration."}