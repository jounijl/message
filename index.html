<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640" />
    
    <META NAME="description" CONTENT="Unicode stream messaging library." />
    <META NAME="author" CONTENT="Jouni Laakso" /> 
    <META NAME="copyright" CONTENT="&copy; Jouni Laakso" /> 
    <META HTTP-EQUIV="Software" CONTENT="Message, stream messaging library." />
    <!-- <META HTTP-EQUIV="Copyright" CONTENT="Jouni Laakso" /> -->
    <META NAME="robots" CONTENT="index,follow" />
    
    <META NAME="keywords" CONTENT="Unicode stream, Unicode stream reader, List, 
    Stream processor, Parallel processing, Data stream mining, Stream library, 
    Unicode dataflow, Stream programming library, Event stream processing, 
    Streaming algorithm, Message passing, Inter-process communication, IPC, Unicode,
    Message, Internet Message, Internet Message Format,
    UTF-8, UTF-16, UTF-32, RFC 5198, RFC 3629, RFC 20, RFC 2822, RFC 822" />

    <META NAME="keywords" LANG="fi" CONTENT="Tietovirta, Stream, Unicode tietovirta, 
    Unicode, Lista, Arvoparit, Tietovirtakirjasto, IPC, Viestinvälitys, 
    Unicode stream, Unicode stream reader, Data stream mining, Message, Internet Message,
    Internet Message Format,
    UTF-8, UTF-16, UTF-32, RFC 5198, RFC 3629, RFC 20, RFC 2822, RFC 822" />

    <META NAME="keywords" LANG="fr" CONTENT="Flot de données, Unicode, 
    UTF-8, UTF-16, UTF-32, IPC, la communication entre des processus, 
    RFC 5198, RFC 3629, RFC 20, RFC 2822, RFC 822" />

    <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
    <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>Message by jounijl</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/jounijl/message">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>Message</h1>
            <h2>  " Unicode stream reader. "  </h2>
                <!-- Unicode dataflow library. --> 
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/jounijl/message/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/jounijl/message/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h3>Stream reader and writer</h3>

<p>Librarys main purpose are seven functions: </p>

<pre><code>int  cb_set_cursor_ucs(CBFILE **cbs, char **ucsname, int *namelength);
int  cb_remove_name_from_stream(CBFILE **cbs);
</code></pre>

<p>cb_set_cursor_ucs finds a name from streams name-value pairs and sets the cursor to the end of the name. 
While the function is reading the stream it places it's data in a buffer and saves every name it finds in it's 
memory structure. It finds every name from the buffer according to it's data structures information of offsets of 
the names when reading again. </p>

<p>The buffer does not move with the stream. When the end of the buffer is reached, name-value pairs must be in 
the order they are used. It is best if name-value pairs are in the same order in the input as is the order of 
using them. If buffer end is reached, CBSTREAM is returned. If this occurs, the last names value may be at the 
border of the buffer. In these cases the name must be removed from data structure with cb_remove_name_from_stream. </p>

<p>If you get CBSTREAM when reading a character, the block read has reached the buffer boundary and the character is 
not automatically saved in the buffer anymore.</p>

<pre><code>int  cb_get_chr(CBFILE **cbs, unsigned long int *chr, int *bytecount, int *storedbytes);
int  cb_put_chr(CBFILE **cbs, unsigned long int *chr, int *bytecount, int *storedbytes);
int  cb_flush(CBFILE **cbs);
</code></pre>

<p>Library reads UCS 32-bit length characters from UTF-8 transfer data. It reads and writes to or from one byte or UTF-8 encoded transfer data.</p>

<p>Program sets bytecount and storedbytes both in reading and writing. Bytecount is the count of bytes in 'chr' and storedbytes is the stored size in stream.</p>

<p>cb_flush empties data written to block to output stream. It can be done anytime and it must be done after last write. 
Allways when the block is full, it is written to output.</p>

<p>Automatic encoding detection based on first bytes BOM is added. It is possible to use also UTF-16 and 
UTF-32 transfer encoding or any two or four byte encoding. 
</p>

<h4>Data structures</h4>

<p>Primary data structures in CBFILE are: </p>

<pre><code>typedef struct CBFILE{
        int    fd;      // Stream file descriptor
        cbuf  *cb;      // Data in valuepairs (preferably in application order)
        cblk  *blk;     // Input read or output write -block 
...
} CBFILE;
</code></pre>

<ul>
<li>file descriptor to read or write, fd</li>
<li>block to read or write, cblk</li>
<li>buffer to save read stream, cbuf</li>
</ul><p>Primary data structures in structure to save the names are: </p>

<pre><code>typedef struct cb_name{
...
        char  *namebuf; // name
        int   namelen; // name length
        int   offset; // offset from the beginning of data
        void  *next; // Last is NULL
...
} cb_name;
</code></pre>

<p>
  It is a linked list. This is to understand what happens in the library. Only above 
  functions and CBFILE allocation functions are meant to be used:
</p>

<pre><code>int  cb_allocate_cbfile(CBFILE **cbs, int fd, int bufsize, int blocksize);
int  cb_free_cbfile(CBFILE **cbs);
</code></pre>

<p>Remember to free CBFILE:s memory after use.</p>

<h4>Data read</h4>

<p>
  Data written and read are valuepairs. Value name may contain comments (between # and \n). 
  Flow control characters are:
</p>

<pre><code>'=' Separates data from it's name
'&amp;' Separates pairs
'\' Escapes next flow control character
'#' Comment to next newline
</code></pre>

<p>
  Characters can be set to another. They can be any characters in 32-bit format. 
</p>
<p>
  It is possible to set unfolding ('unfold' in cb_conf) to remove linear white space characters before 
  space or horizontal tabs when reading the names as in RFC 2822. It is also possible to remove whitespaces, tabs and 
  newline -characters between values and names ('removewsp' and 'removecrlf' in cb_conf). 
</p>

<p>For example:</p>

<pre><code>name_of_value=data_of_value&amp;another_name=another_data&amp;   third_name=third_data&amp;
      fourthname =fourth_data&amp; # Comment
name of last pair =last_p\&amp;air\\s_data&amp; 
</code></pre>

<p>
  Last pairs value has control characters. cb_get_chr function reads 
  characters without flow control. It's in the programmers responsibility 
  to implement bypass with '\' and read beyond "\&amp;" after reading the characters if it's necessary.
</p>
<p>
  The cursor should be left at the end of the value at character '&amp;' after reading to search the 
  names again correctly.
</p>

<p>Example of nesting consecutive streams:</p>

<pre><code>data_field {
  name1 = value1;
  name2 = value2; # Comment 
}
</code></pre>

<p>
  Library can be used for example in reading or writing configuration files, 
  reading a POST responce from browser, parsing internet message header files 
  or in interprocess messaging.
</p>
<p>Include -files contain specific notes on defines and explanations of other functions.</p>

<h5>Return values</h5>
<p>Return values are listed in:</p>
<pre><code>cb_buffer.h</code></pre>
<p>
  Return values between CBSUCCESS and CBNEGATION are informative. Values between CBNEGATION and CBERROR describe a usually occurring event. 
  For example CBNOTUTF informs that the stream contained unrecognized bytes and it should be handled by the programmer as a special case. 
  Errors above CBERROR should not occur and they usually depend on the outside resources, memory allocation, file operations or programming 
  errors using the function calls.
</p>


<h3>Issues and bug tracking</h3>

<p>Information about using, issues in using and bug reports are welcomed. Using the library validates it.</p>
<p>New features should be tested before use.</p>

<p><strong>Page history</strong>
<a href="http://jounijl.github.com/message">http://jounijl.github.com/message</a>
17.3.2013</p>
<p><strong>Page last update</strong> 9.9.2013</p>
<p>
  <table rules="none" border="0" align="left" frame="void">
    <caption><em><strong>Release history</strong></em></caption>
    <tr><td><strong><strong>Branch</strong></td><td><strong>&nbsp;</strong></td><td><strong>Tag</strong></td>
                                                 <td><strong>Merge</strong></td><td><strong>Release</strong></td></tr>
    <tr> <td>'ucsflowcontrol'</td> <td>6.4.2013</td> <td>v1.0.0</td> <td>16.8.2013</td> <td>v1.0.0</td> </tr>
    <tr> <td>'maintenance'</td> <td>21.8.2013</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> </tr>
    <tr> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> <td>&nbsp;</td> </tr>
  </table>
</p>
<!-- <p><strong>Branch</strong> 'ucsflowcontrol' 6.4.2013</p>
<p><strong>Branch</strong> 'maintenance' 21.8.2013</p>
<p><strong>Merge</strong> v1.0.0 16.8.2013, ucsflowcontrol</p> -->
<p><strong>References</strong> 
<ul>
<li>RFC-822  "Standard Format of the ARPA Internet Text Messages"</li>
<li>RFC-2822 "Internet Message Format"</li>
<li>RFC-2616 "Hypertext Transfer Protocol"</li>
<li>RFC-5198 "Unicode Format for Network Interchange"</li>
<li>RFC-3629 "UTF-8, a transformation format of ISO 10646"</li>
<li>RFC-20   "ASCII format for Network Interchange"</li>
</ul>
</p>

<h3>Authors and Contributors</h3>

<p>Jouni L., email: jnl (cat) iki (dot) fi.</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/jounijl">jounijl</a> can be found on <a href="https://github.com/jounijl/message">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p><!--- Unicode Encoded --> <a href="http://www.unicode.org/">
        <img border="0" src="http://www.unicode.org/img/UniEncWhite.gif" alt="Unicode Encoded"></a></p>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-39364465-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
